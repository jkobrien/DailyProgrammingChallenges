# GeeksforGeeks Problem of the Day - October 3, 2025

## Problem: Possible Words From Phone Digits

**Difficulty:** Medium  
**Companies:** Flipkart, Amazon, Microsoft  
**Accuracy:** 52.79%  
**Submissions:** 79K+  

---

## Problem Statement

You are given a keypad (as shown in the diagram) and an array `arr[]` containing digits, your task is to list all possible words in any order which can be generated by pressing numbers in `arr[]` sequentially.

**Note:** 
- Number 0 and 1 do not map to any letters
- You can return the words in any order, the driver code will print them in sorted order

### Phone Keypad Mapping
```
2: abc
3: def
4: ghi
5: jkl
6: mno
7: pqrs
8: tuv
9: wxyz
```

---

## Examples

### Example 1
**Input:** `arr[] = [2, 3]`  
**Output:** `[ad, ae, af, bd, be, bf, cd, ce, cf]`  
**Explanation:** When we press 2 and 3, total 3 × 3 = 9 possible words are formed.

### Example 2
**Input:** `arr[] = [2]`  
**Output:** `[a, b, c]`  
**Explanation:** When we press 2, total 3 possible words are formed.

---

## Constraints
- `1 ≤ arr.size() ≤ 9`
- `0 ≤ arr[i] ≤ 9`

---

## Approach

This problem can be solved using **iterative combination generation** approach:

1. **Phone Mapping:** Create a hashtable mapping each digit (2-9) to its corresponding letters
2. **Filter Valid Digits:** Remove digits 0 and 1 as they don't map to any letters
3. **Iterative Generation:** For each valid digit, expand all existing combinations by appending each possible letter
4. **Sorting:** Return the final combinations sorted alphabetically

### Algorithm Steps:
1. Start with an array containing one empty string
2. For each digit in the input:
   - Get all letters mapped to that digit
   - For each existing combination, create new combinations by appending each letter
   - Replace the combinations array with the new expanded combinations
3. Return sorted results

### Time Complexity: O(3^N × 4^M)
- Where N is the number of digits mapping to 3 letters (2,3,4,5,6,8)
- Where M is the number of digits mapping to 4 letters (7,9)
- In worst case: O(4^N) where N is length of input

### Space Complexity: O(3^N × 4^M)
- For storing all possible combinations

---

## PowerShell Implementation

### Core Function
```powershell
function Get-PossibleWords {
    param([int[]]$digits)
    
    # Phone keypad mapping
    $phoneMap = @{
        2 = @('a', 'b', 'c')
        3 = @('d', 'e', 'f')
        4 = @('g', 'h', 'i')
        5 = @('j', 'k', 'l')
        6 = @('m', 'n', 'o')
        7 = @('p', 'q', 'r', 's')
        8 = @('t', 'u', 'v')
        9 = @('w', 'x', 'y', 'z')
    }
    
    # Handle edge cases and generate combinations iteratively
    # ... (see full implementation in the script)
}
```

---

## Usage

### Running the Solution
```powershell
# Navigate to the problem directory
cd "c:\Code\GitHub\DailyProgrammingChallenges\ProblemOfTheDay\2025-10-03_PossibleWordsFromPhoneDigits"

# Run the script (includes tests and benchmarks)
pwsh -File .\possible_words_from_phone_digits.ps1

# Or import and use the function directly
. .\possible_words_from_phone_digits.ps1
$result = Get-PossibleWords -digits @(2, 3)
Write-Host "Result: [$($result -join ', ')]"
```

### Example Usage
```powershell
# Example 1: Two digits
Get-PossibleWords -digits @(2, 3)
# Output: @("ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf")

# Example 2: Single digit
Get-PossibleWords -digits @(7)
# Output: @("p", "q", "r", "s")

# Example 3: Three digits
Get-PossibleWords -digits @(2, 3, 4)
# Output: 27 combinations (adg, adh, adi, ...)
```

---

## Test Results

The solution includes comprehensive testing with the following test cases:

| Test Case | Input | Expected Output | Status |
|-----------|-------|----------------|---------|
| Basic case | [2, 3] | 9 combinations | ✅ PASS |
| Single digit | [2] | 3 combinations | ✅ PASS |
| Digit 7 | [7] | 4 combinations | ✅ PASS |
| Three digits | [2, 3, 4] | 27 combinations | ✅ PASS |
| Empty input | [] | Empty array | ✅ PASS |
| Invalid digits | [0, 1] | Empty array | ✅ PASS |

**All tests passed: 6/6** ✅

---

## Performance Benchmark

| Input Size | Digits | Combinations | Time |
|------------|--------|-------------|------|
| Small | [2, 3] | 9 | 1 ms |
| Medium | [2, 3, 4] | 27 | 0 ms |
| Large | [2, 3, 4, 5] | 81 | 0 ms |

---

## Key Features

- ✅ **Correct Implementation:** Handles all edge cases and produces expected output
- ✅ **Comprehensive Testing:** 6 test cases covering various scenarios
- ✅ **Performance Optimized:** Iterative approach avoids recursion overhead
- ✅ **Well Documented:** Clear comments and documentation
- ✅ **Error Handling:** Handles empty input and invalid digits gracefully
- ✅ **Sorted Output:** Results are automatically sorted alphabetically

---

## Alternative Approaches

1. **Recursive Backtracking:** Traditional recursive approach (more intuitive but potentially slower)
2. **Dynamic Programming:** Build combinations bottom-up
3. **Queue-based BFS:** Use queue to generate combinations level by level

The implemented iterative approach is chosen for its simplicity and efficiency in PowerShell.

---

## Related Problems

- Letter Combinations of a Phone Number (LeetCode 17)
- Generate Parentheses (LeetCode 22)
- Permutations (LeetCode 46)
- Combinations (LeetCode 77)

---

*Solution completed on October 3, 2025*